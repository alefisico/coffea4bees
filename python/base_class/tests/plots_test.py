import unittest
from coffea.util import load
import yaml
import sys
import os
sys.path.insert(0, os.getcwd())
from base_class.plots.plots import get_value_nested_dict, makePlot, load_config, load_hists, read_axes_and_cuts, get_cut_dict, get_value_nested_dict, get_values_centers_from_dict
import sys
import base_class.plots.iPlot_config as cfg
import numpy as np
from base_class.tests.parser import wrapper
from unittest.mock import MagicMock
import matplotlib.pyplot as plt

#
# python3 analysis/tests/plot_test.py   --inputFile analysis/hists/test.coffea --knownCounts base_class/tests/plotCounts.yml 
#

class PlotTestCase(unittest.TestCase):

    @classmethod
    def setUpClass(self):

        #self.plotsAllDict = yaml.safe_load(open(, 'r'))
        metadata = "analysis/metadata/plotsAll.yml"
        #inputFile = "analysis/hists/test.coffea"
        inputFile = wrapper.args["inputFile"]
        
        cfg.plotConfig = load_config(metadata)
        cfg.hists = load_hists([inputFile])
        cfg.axisLabels, cfg.cutList = read_axes_and_cuts(cfg.hists, cfg.plotConfig)

        #  Make these numbers with:
        #  >  python     base_class/tests/dumpPlotCounts.py --input [inputFileName] -o [outputFielName]
        #       (python base_class/tests/dumpPlotCounts.py --input analysis/hists/test.coffea --output base_class/tests/testPlotCounts.yml)
        #
        knownCountFile = wrapper.args["knownCounts"] 
        self.knownCounts = yaml.safe_load(open(knownCountFile, 'r'))
        

    def test_get_value_nested_dict(self):
        
        testDict = {"dA0" : {"dA1" : {"dA2": {"ka0" : "va0", "ka1" : "va1"} }, "ka2" : "va2"},
                    "dB0" : {"kb0" : "vb0"},
                    "kb1" : "vb1"}
            
        self.assertEqual(get_value_nested_dict(testDict, "ka0"), "va0")
        self.assertEqual(get_value_nested_dict(testDict, "ka1"), "va1")
        self.assertEqual(get_value_nested_dict(testDict, "ka2"), "va2")
        self.assertEqual(get_value_nested_dict(testDict, "kb0"), "vb0")
        self.assertEqual(get_value_nested_dict(testDict, "kb1"), "vb1")

        
        value = get_value_nested_dict(cfg.plotConfig["hists"], "year")
        self.assertEqual(value, "RunII")

        value = get_value_nested_dict(cfg.plotConfig, "year")
        self.assertEqual(value, "RunII")        

        value = get_value_nested_dict(cfg.plotConfig, "fillcolor")
        self.assertEqual(value, "k")        

    # Generated by chatGPT4
    def test_get_cut_dict(self):
        cut = 'cut1'
        cutList = ['cut1', 'cut2', 'cut3']
        
        # Call the function
        result = get_cut_dict(cut, cutList)
        
        # Check the result is a dictionary
        self.assertIsInstance(result, dict, "The result should be a dictionary.")
        
        # Check the dictionary has all the cuts from cutList as keys
        self.assertTrue(all(c in result for c in cutList), "All cuts should be keys in the result dictionary.")
        
        # Check the specified cut is True
        self.assertTrue(result[cut], "The specified cut should be True.")
        
        # Check all other cuts are sum
        for c in cutList:
            if c != cut:
                self.assertTrue(result[c] == sum, f"{c} should be marked as sum.")


        
    def test_counts(self):        

        default_args = {"doRatio":0, "rebin":4, "norm":0, "process":"Multijet"}

        for k, v  in self.knownCounts.items():
            print(f"testing...{k}")
            var = v["var"]
            cut = v["cut"]
            region = v["region"]
            counts = v["counts"]

            fig, ax = makePlot(cfg, var=var, cut=cut, region=region,
                               outputFolder=cfg.outputFolder, **default_args)


            for i in range(len(ax.lines)):
            
                if hasattr(ax.lines[i], "get_label") and ax.lines[i].get_label() == '_nolegend_':
                    y_plot = ax.lines[i].get_ydata()
                    break
            
            np.testing.assert_allclose(y_plot, counts,
                                       rtol=1e-10, atol=0)
            plt.close()

    def test_get_values_centers_from_dict_hists_type(self):
        # Mocking histogram objects
        hist_mock = MagicMock()
        hist_mock.values.return_value = np.array([1, 2, 3])
        hist_mock.axes[0].centers = np.array([0.5, 1.5, 2.5])

        # Mocking histogram config
        hist_config = {"name": "hist1"}
        
        # Setting up inputs
        input_dict = {"type": "hists", "key": "hist1"}
        hist_index = {"hist1": 0}
        hists = [(hist_mock, hist_config)]
        stack_dict = {}
        
        # Expected values
        expected_values = np.array([1, 2, 3])
        expected_centers = np.array([0.5, 1.5, 2.5])
        
        # Test
        values, centers = get_values_centers_from_dict(input_dict, hists, stack_dict)
        np.testing.assert_array_equal(values, expected_values)
        np.testing.assert_array_equal(centers, expected_centers)


    def test_stack_type(self):
        # Mocking histogram objects
        hist_mock = MagicMock()
        hist_mock.values.return_value = np.array([1, 2, 3])
        hist_mock.axes[0].centers = np.array([0.5, 1.5, 2.5])
        stack_dict = {"stack1": (hist_mock, {}), "stack2": (hist_mock, {})}

        # Setting up inputs
        input_dict = {"type": "stack"}
        hist_index = {}
        hists = []
        
        # Expected values (sum of two histograms)
        expected_values = np.array([2, 4, 6])
        expected_centers = np.array([0.5, 1.5, 2.5])
        
        # Test
        values, centers = get_values_centers_from_dict(input_dict, hists, stack_dict)
        np.testing.assert_array_equal(values, expected_values)
        np.testing.assert_array_equal(centers, expected_centers)        

            

if __name__ == '__main__':
    wrapper.parse_args()
    unittest.main(argv=sys.argv)

